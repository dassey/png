<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PNG Chunk Inspector</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Add some basic styles for table layout */
        #chunk-table th, #chunk-table td {
            padding: 0.5rem; /* p-2 */
            border: 1px solid #d1d5db; /* border border-gray-300 */
            vertical-align: top;
        }
        #chunk-table th {
            background-color: #f3f4f6; /* bg-gray-100 */
            text-align: left;
            font-weight: 600; /* font-semibold */
        }
        .text-right { text-align: right; }
        .hidden { display: none; }
        pre {
            white-space: pre-wrap; /* Allow wrapping */
            word-break: break-all; /* Break long words */
            font-family: monospace;
            font-size: 0.875rem; /* text-sm */
            background-color: #f9fafb; /* bg-gray-50 */
            padding: 0.5rem; /* p-2 */
            border-radius: 0.375rem; /* rounded-md */
            border: 1px solid #e5e7eb; /* border border-gray-200 */
            max-height: 200px; /* Limit height */
            overflow-y: auto; /* Add scroll if needed */
        }
    </style>
</head>
<body class="font-sans bg-gray-50 text-gray-800 p-4 md:p-8">

    <div class="max-w-4xl mx-auto bg-white p-6 rounded-lg shadow-md">
        <h1 class="text-2xl font-bold mb-4 text-center text-gray-700">PNG File Chunk Inspector</h1>

        <div class="mb-4">
            <label for="input-file" class="block text-sm font-medium text-gray-700 mb-1">Select PNG file:</label>
            <input type="file" id="input-file" accept=".png,image/png" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 border border-gray-300 rounded-md cursor-pointer focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"/>
        </div>

        <div class="text-center mb-4">
             <button id="analyze-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-150 ease-in-out">Analyze PNG</button>
        </div>

        <div id="message" class="mt-4 text-center text-sm text-red-600 font-medium"></div>

        <div class="mt-6 overflow-x-auto">
            <table id="chunk-table" class="w-full border-collapse hidden">
                <thead class="bg-gray-100">
                    <tr>
                        <th data-key="offset" class="text-right">Offset</th>
                        <th data-key="length" class="text-right">Length</th>
                        <th data-key="type">Type</th>
                        <th data-key="crc" class="text-right">CRC-32</th>
                        <th data-key="summary">Summary</th>
                        <th data-key="dump">Data Dump</th>
                    </tr>
                </thead>
                <tbody>
                    </tbody>
            </table>
        </div>
    </div>

    <script src="png.js"></script>

    <script>
        // Get references to DOM elements
        const fileElem = document.getElementById("input-file");
        const analyzeButton = document.getElementById("analyze-button");
        const messageElem = document.getElementById("message");
        const chunkTable = document.getElementById("chunk-table");
        const chunkTableBody = chunkTable.querySelector("tbody");

        // Set of chunk types for which to display a hex/ASCII dump
        const CHUNK_TYPES_TO_DUMP = new Set(["gAMA", "sRGB", "pHYs", "iTXt", "tEXt", "zTXt", "tIME", "cHRM", "iCCP", "sBIT", "cICP", "bKGD", "hIST", "sPLT", "eXIf"]);

        // --- PNG Parsing and Rendering Functions (Copied & adapted from png.js) ---
        // Note: These functions rely on helper functions defined within png.js

        // Takes the raw bytes of a PNG file, returns a list of chunk objects, throwing an exception if error.
        function readPngChunks(bytes) {
            // Check file signature (PNG_SIGNATURE is defined in png.js)
            if (bytes.length < 8 || !bytes.subarray(0, 8).every((b, i) => (b === PNG_SIGNATURE[i])))
                throw "Not a PNG file";

            // Parse chunks
            let chunks = [];
            let index = 8;
            while (index < bytes.length) {
                // Parse chunk header
                if (index + 8 > bytes.length)
                    throw "Unexpected end of file (chunk header)";
                // readUint32 is defined in png.js
                let length = readUint32(bytes, index + 0);
                if (length >= 0x80000000) // Check for potential overflow/error
                    throw "Chunk length too large";
                // readAscii is defined in png.js
                let type = readAscii(bytes, index + 4, 4);
                if (!/^[A-Za-z]{4}$/.test(type)) // Validate chunk type format
                    throw "Chunk type has invalid characters";

                // Check for sufficient data for chunk data and CRC
                if (index + 8 + length + 4 > bytes.length)
                    throw "Unexpected end of file (chunk data or CRC)";

                // Get chunk data subarray
                let data = bytes.subarray(index + 8, index + 8 + length);

                // Parse and verify chunk CRC
                let actualCrc = readUint32(bytes, index + 8 + length);
                let typeBytes = new Uint8Array(4);
                for (let i = 0; i < 4; i++)
                    typeBytes[i] = type.charCodeAt(i);

                // computeCrc is defined in png.js
                let expectedCrc = computeCrc(typeBytes, data);
                if (actualCrc !== expectedCrc) {
                    console.warn(`Chunk CRC mismatch for ${type}: Expected ${formatHex(expectedCrc, 8)}, Got ${formatHex(actualCrc, 8)}`);
                    // Decide whether to throw an error or just warn. The example site seems to continue.
                    // throw "Chunk CRC mismatch";
                }


                // Store chunk information
                chunks.push({
                    type : type,
                    length : length,
                    data : data,
                    offset : index,
                    crc: actualCrc // Store the actual CRC read from file
                });
                index += 8 + length + 4; // Move to the next chunk

                // Check for data after IEND chunk
                if (type === "IEND" && index < bytes.length) {
                    console.warn("Warning: File continues after IEND chunk");
                    // Optionally break or stop processing here if desired
                    // break;
                }
            }

            // Check for essential chunks
            if (chunks.length === 0 || chunks[0].type !== "IHDR")
                throw "Missing or misplaced IHDR chunk (must be the first chunk)";
            if (chunks[chunks.length - 1].type !== "IEND")
                 console.warn("Warning: Missing IEND chunk or file truncated"); // Be more lenient than throwing error
            let hasIdat = chunks.some(ch => (ch.type === "IDAT"));
            if (!hasIdat)
                throw "Missing IDAT chunk (no image data)";

            return chunks;
        }


        // Renders the given list of chunk objects into the page DOM. Also requires the raw file bytes.
        function renderChunks(chunks) {
            messageElem.textContent = "File parsed successfully";
            chunkTable.classList.remove("hidden");

            // Clear previous results
            while (chunkTableBody.firstChild) {
                chunkTableBody.removeChild(chunkTableBody.firstChild);
            }

            // Get table header info (for mapping data keys to cells)
            let headers = chunkTable.querySelector("thead tr").cells;
            let colInfos = [];
            for (let i = 0; i < headers.length; i++) {
                colInfos.push({
                    name: headers[i].dataset.key, // Get the key from data-key attribute
                    isRight: headers[i].classList.contains("text-right")
                });
            }

            // Iterate through each chunk and create a table row
            for (const chunk of chunks) {
                let row = chunkTableBody.insertRow();

                // Create cells based on header info
                let cells = {};
                for (const info of colInfos) {
                    let cell = row.insertCell();
                    // Apply basic styling (Tailwind classes equivalent)
                    cell.style.padding = '0.5rem';
                    cell.style.border = '1px solid #d1d5db';
                    cell.style.verticalAlign = 'top';
                    if (info.isRight) {
                        cell.style.textAlign = 'right';
                    }
                    cells[info.name] = cell; // Store cell reference by key
                }

                // Populate cells with chunk data
                // formatNumber and formatHex are defined in png.js
                cells.offset.textContent = formatNumber(chunk.offset);
                cells.length.textContent = formatNumber(chunk.length);
                cells.type.textContent = chunk.type;
                cells.crc.textContent = formatHex(chunk.crc, 8); // Use the CRC read from the file

                // Get and display chunk summary
                let summary = "";
                try {
                    // summarizeChunk is defined in png.js
                    summary = summarizeChunk(chunk);
                } catch (e) {
                    console.error(`Error summarizing chunk ${chunk.type}:`, e);
                    summary = `Error: ${e.message || e.toString()}`; // Display error message
                }
                cells.summary.textContent = summary;

                // Display data dump if the chunk type is in the set
                if (CHUNK_TYPES_TO_DUMP.has(chunk.type)) {
                    const dumpContent = dumpChunkData(chunk.data);
                    // Use <pre> for better formatting of the dump
                    const pre = document.createElement('pre');
                    pre.textContent = dumpContent;
                    cells.dump.appendChild(pre);
                } else {
                     cells.dump.textContent = '—'; // Indicate no dump for this type
                }
            }
        }

        // --- Event Listener Setup ---
        analyzeButton.onclick = function() {
            // Clear previous state
            messageElem.textContent = "";
            while (chunkTableBody.firstChild !== null)
                chunkTableBody.removeChild(chunkTableBody.firstChild);
            chunkTable.classList.add("hidden");

            // Check if a file is selected
            let files = fileElem.files;
            if (files.length < 1) {
                messageElem.textContent = "No file selected";
                return;
            }

            // Use FileReader to read the file
            let reader = new FileReader();

            // Define what happens when the file is loaded
            reader.onload = function() {
                try {
                    // Get file content as ArrayBuffer, then convert to Uint8Array
                    let bytes = new Uint8Array(reader.result);
                    // Parse the PNG chunks using the library function
                    let chunks = readPngChunks(bytes);
                    // Render the parsed chunks into the table
                    renderChunks(chunks);
                } catch (e) {
                    // Display any errors that occur during parsing
                    messageElem.textContent = `Error: ${e.message || e.toString()}`;
                    console.error("PNG Parsing Error:", e);
                }
            };

            // Define what happens on file reading error
            reader.onerror = function() {
                messageElem.textContent = "File reading error";
                console.error("File Reading Error:", reader.error);
            };

            // Start reading the file
            messageElem.textContent = "Reading and analyzing file...";
            reader.readAsArrayBuffer(files[0]);
        };

        // Optional: Trigger analysis automatically when a file is selected
        // fileElem.onchange = () => analyzeButton.click();

    </script>

</body>
</html>
